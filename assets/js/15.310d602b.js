(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{451:function(t,a,s){"use strict";s.r(a);var r=s(65),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"后端代码在前端开发有哪些好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后端代码在前端开发有哪些好处"}},[t._v("#")]),t._v(" 后端代码在前端开发有哪些好处？")]),t._v(" "),s("blockquote",[s("p",[t._v("前后端约定好的接口，在实际开发过程中，都需要调整，这时，后端写好的代码有可能面临多次要被改写的窘境，白白浪费大量的时间！前端在开发的过程中，根据实际需要处理数据，免去和后端沟通，自然效率就要高得多!")])]),t._v(" "),s("h2",{attrs:{id:"aca-ts-是如何实现后端代码在前端开发的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aca-ts-是如何实现后端代码在前端开发的"}},[t._v("#")]),t._v(" Aca.ts 是如何实现后端代码在前端开发的？")]),t._v(" "),s("blockquote",[s("p",[t._v("应用软件的开发，大部分时间都是和数据库打交道，aca.ts 可以把数据库查询的 API 桥接到前端，使得前端访问数据库就跟后端访问数据库的方式是一样的，对开发者没有任何差异。后端的函数（我们称之为远程函数）也会被自动生成为前端同名的接口，这样前端代码也可以使用跟后端同名的函数，这样前端的代码在相对稳定后，可以较为平直的移到后端，形成一个新的远程函数。")])]),t._v(" "),s("h2",{attrs:{id:"为什么只提供-typescript-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么只提供-typescript-api"}},[t._v("#")]),t._v(" 为什么只提供 typescript API?")]),t._v(" "),s("blockquote",[s("p",[t._v("TS 具有很好的代码提示功能，可大幅减少调试时间。")])]),t._v(" "),s("h2",{attrs:{id:"前端是如何访问后端的-需要定义路由吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端是如何访问后端的-需要定义路由吗"}},[t._v("#")]),t._v(" 前端是如何访问后端的？需要定义路由吗？")]),t._v(" "),s("blockquote",[s("p",[t._v("后端的数据库查询 API 和远程函数会被生成前端同名（支持命名空间）的函数，该函数体是 fetch 方法，将相关参数传到后端时，有一个叫 apiBridge 的函数将传入的参数处理为与前端同名的函数，并调用后返回。不需要定义路由。")])]),t._v(" "),s("h2",{attrs:{id:"远程函数如何获取上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#远程函数如何获取上下文"}},[t._v("#")]),t._v(" 远程函数如何获取上下文？")]),t._v(" "),s("blockquote",[s("p",[t._v("函数的第一个参数为上下文，在生成前端的同名函数时，会把这个参数省去。")])]),t._v(" "),s("h2",{attrs:{id:"node-js-包如何引用到-web-前端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-js-包如何引用到-web-前端"}},[t._v("#")]),t._v(" Node.js 包如何引用到 web 前端？")]),t._v(" "),s("blockquote",[s("p",[t._v("建议将需要引用的 node.js 包统一封装在一个远程函数里，这样前端就可以通过这个函数提供的接口使用。")])]),t._v(" "),s("h2",{attrs:{id:"orm-文档如何表述多个数据库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#orm-文档如何表述多个数据库"}},[t._v("#")]),t._v(" ORM 文档如何表述多个数据库？")]),t._v(" "),s("blockquote",[s("p",[t._v("每一个顶级命名空间就代表一个数据库，需要多个数据库，就需要多个顶级命名空间。")])]),t._v(" "),s("h2",{attrs:{id:"为什么目前支持的数据库比较少"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么目前支持的数据库比较少"}},[t._v("#")]),t._v(" 为什么目前支持的数据库比较少？")]),t._v(" "),s("blockquote",[s("p",[t._v("Aca.ts 底层调用 knex.js 与数据库打交道，并大量使用 returning 方法，所有就只支持具有该方法的数据库。")])]),t._v(" "),s("h2",{attrs:{id:"aca-ts-是否可以只在前端运行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aca-ts-是否可以只在前端运行"}},[t._v("#")]),t._v(" Aca.ts 是否可以只在前端运行？")]),t._v(" "),s("blockquote",[s("p",[t._v("Aca.ts 必须启动一个后端服务。前端接口实际上是访问后端的同名函数。所以不能只运行在前端。")])]),t._v(" "),s("h2",{attrs:{id:"aca-ts-可以只用于后端吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aca-ts-可以只用于后端吗"}},[t._v("#")]),t._v(" Aca.ts 可以只用于后端吗？")]),t._v(" "),s("blockquote",[s("p",[t._v("可以，此时就是一个标准的数据库 ORM。")])]),t._v(" "),s("h2",{attrs:{id:"前端能访问数据库-数据安全吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端能访问数据库-数据安全吗"}},[t._v("#")]),t._v(" 前端能访问数据库，数据安全吗？")]),t._v(" "),s("blockquote",[s("p",[t._v("与传统开发没什么差别，前端访问数据库是桥接到后端进行的，可以对数据进行拦截，做好相应的安全性校验。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);